#!/usr/bin/env python3

import botocore
import boto3
import argparse
import tabulate
import time
from halo import Halo

"""
Usage:

manage-eks-nodes-state-per-az.py [-h] -c EKS_CLUSTER_NAME -z AVAILABILITY_ZONE_NAME -t ACTION_TYPE [-d DRY_RUN]

optional arguments:
  -h, --help            show this help message and exit
  -c EKS_CLUSTER_NAME, --cluster EKS_CLUSTER_NAME
                        EKS Cluster Name
  -z AVAILABILITY_ZONE_NAME, --availability-zone AVAILABILITY_ZONE_NAME
                        AZ name where EKS nodes needs to be stopped
  -t ACTION_TYPE, --action-type ACTION_TYPE
                        Define action type: start/stop/terminate/status
  -d DRY_RUN, --dry-run DRY_RUN
                        Perform dry run
"""

# This script lists instances of a given az to stop/start

#----------------------- PARAMETERS / CONFIGURATION ---------------------------


#-----------------------------------------------------------------------------#

def spinner(display_text, time_delay):
  spinner = Halo(text=display_text, spinner='dots')
  spinner.start()
  time.sleep(time_delay)
  spinner.stop()


def print_instances_list(instances_list_with_names):
    if instances_list_with_names:
        header = instances_list_with_names[0].keys()
        rows = [x.values() for x in instances_list_with_names]
        print(tabulate.tabulate(rows, header))
    else:
        print("Failed to list! ‚ùå Instances list is empty ‚ùå")


def print_instances_status(instance_status):
    if instance_status:
        header = instance_status[0].keys()
        rows = [x.values() for x in instance_status]
        print(tabulate.tabulate(rows, header))
    else:
        print("‚ùï Instances status is empty, instance is either in stopping|pending|stopped STATE ‚ùï")


def get_instances_list_with_names(ec2_client, eks_cluster_name, availability_zone_name):
    instances_list_with_names = []

    paginator = ec2_client.get_paginator('describe_instances')
    page_iterator = paginator.paginate(
                        Filters=[
                            {
                                'Name': 'tag:kubernetes.io/cluster/'+eks_cluster_name,
                                'Values': [
                                    'owned',
                                ],
                            },
                            {
                                'Name': 'availability-zone',
                                'Values': [
                                    availability_zone_name,
                                ],
                            },
                        ],
                    )

    for page in page_iterator:
        for reservation in page['Reservations']:
            for instance in reservation['Instances']:
                if instance['State']['Name'] != 'terminated':
                    if any('Tags' in key for key in instance):
                        name = [tag['Value'] for tag in instance['Tags'] if tag['Key'] == 'Name'][0]
                    else:
                        name = "None"

                    instances_list_with_names.append({"id": instance['InstanceId'], "name": name, "state":instance['State']['Name']})

    return(instances_list_with_names)


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--cluster', dest='eks_cluster_name', type=str, 
                        help="EKS Cluster Name", required=True)
    parser.add_argument('-z', '--availability-zone', dest='availability_zone_name', type=str,
                        help="AZ name where EKS nodes needs to be stopped", required=True)
    parser.add_argument('-t', '--action-type', dest='action_type', type=str,
                        help="Define action type: start/stop/terminate/status", required=True)
    parser.add_argument('-d', '--dry-run', dest='dry_run', type=str,
                        help="Perform dry run", required=False)
    args = vars(parser.parse_args())

    awsprofile = next(each_cluster['profile']
                      for each_cluster in clusters_mapping if each_cluster['clusterName'] == args['eks_cluster_name'])
    awsregion = next(each_cluster['awsRegion']
                     for each_cluster in clusters_mapping if each_cluster['clusterName'] == args['eks_cluster_name'])

    print("‚ÑπÔ∏è AWS Profile: " + awsprofile)
    print("‚ÑπÔ∏è AWS Region: " + awsregion)
    print("‚ÑπÔ∏è AWS Availibility Zone: " + args['availability_zone_name'])

    # iterate over each aws account
    print('\n‚ÑπÔ∏è ‚è≥ Scanning the availability zone: "' +
          args['availability_zone_name'] + '" for EKS nodes of the: "' + args['eks_cluster_name'] + '" cluster ..')
    spinner("üîé", 5)
    session = boto3.Session(profile_name=awsprofile)

    try:
        ec2_client = session.client('ec2', region_name=awsregion)

        instances_list_with_names = get_instances_list_with_names(
            ec2_client, args['eks_cluster_name'], args['availability_zone_name'])

        # check if instances_list_with_names is not empty
        if instances_list_with_names:
                
            print('\n‚ÑπÔ∏è Found below instances in the availability zone: "' +
                args['availability_zone_name'] + '": ')
            spinner("üñ®Ô∏è", 2)
            print("==============================================================")
            print_instances_list(instances_list_with_names)
            print("==============================================================\n")
    
            # fetch only the instance ids and save it as a list
            instances_ids_list = [each_instance_id['id']
                                for each_instance_id in instances_list_with_names]

            if args['action_type'].lower() == 'start':
                print("\n**************************************************************")
                print("‚ÑπÔ∏è STARTing the instances: \n" +
                    '\n'.join(map(str, instances_ids_list)))
                response = ec2_client.start_instances(
                              InstanceIds=instances_ids_list, DryRun=bool(args['dry_run']))

                if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                    # Wait till instance is in 'running' state
                    spinner("üèÉ", 20)
                    instance_runner_waiter = ec2_client.get_waiter('instance_running')
                    instance_runner_waiter.wait(InstanceIds=instances_ids_list)

                    print("\n‚ÑπÔ∏è Instances: \n" + "'" +
                          '\n'.join(map(str, instances_ids_list)) + "'" + " successfully STARTed ‚úÖ \n")
                    print(response)
                else:
                    print("‚ùå  Instances: \n" + "'" +
                          '\n'.join(map(str, instances_ids_list)) + "'" + " failed to START ‚ùå")

                print("**************************************************************\n")

            elif args['action_type'].lower() == 'stop':
                print("\n**************************************************************")
                print("‚ÑπÔ∏è STOPping the instances: \n" +
                    '\n'.join(map(str, instances_ids_list)))
                response = ec2_client.stop_instances(
                              InstanceIds=instances_ids_list, DryRun=bool(args['dry_run']))

                if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                    # Wait till instance is in 'stopped' state
                    spinner("üßç", 20)
                    instance_stopped_waiter = ec2_client.get_waiter('instance_stopped')
                    instance_stopped_waiter.wait(InstanceIds=instances_ids_list)

                    print("\n‚ÑπÔ∏è Instances: \n" + "'" +
                          '\n'.join(map(str, instances_ids_list)) + "'" + " successfully STOPPed ‚úÖ \n")
                    print(response)
                else:
                    print("‚ùå  Instances: \n" + "'" +
                          '\n'.join(map(str, instances_ids_list)) + "'" + " failed to STOP ‚ùå")

                print("**************************************************************\n")

            elif args['action_type'].lower() == 'terminate':
                print("\n**************************************************************")
                print("‚ÑπÔ∏è TERMINATing the instances: \n" +
                      '\n'.join(map(str, instances_ids_list)))
                response = ec2_client.terminate_instances(
                              InstanceIds=instances_ids_list, DryRun=bool(args['dry_run']))
                if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                    # Wait till instance is in 'terminated' state
                    spinner("ü§∫", 20)
                    instance_terminate_waiter = ec2_client.get_waiter('instance_terminated')
                    instance_terminate_waiter.wait(InstanceIds=instances_ids_list)
                  
                    print("\n‚ÑπÔ∏è Instance: \n" + "'" +
                          '\n'.join(map(str, instances_ids_list)) + "'" + " successfully TERMINATED ‚úÖ \n")
                    print(response)
                else:
                    print("‚ùå  Instance: \n" + "'" +
                          '\n'.join(map(str, instances_ids_list)) + "'" + " failed to TERMINATE ‚ùå") 

                print("**************************************************************\n")

            elif args['action_type'].lower() == 'status' and instances_ids_list:
                print("\n**************************************************************")
                print("\n‚ÑπÔ∏è DESCRIBING status of instances: \n" +
                      '\n'.join(map(str, instances_ids_list)))
                response = ec2_client.describe_instance_status(
                              InstanceIds=instances_ids_list, DryRun=bool(args['dry_run']))

                instance_status=[]
                if response['ResponseMetadata']['HTTPStatusCode'] == 200:
                    for each_status in response['InstanceStatuses']:
                        id = each_status.get('InstanceId', 'Unknown_ID')
                        code = each_status.get(
                            'InstanceState', {}).get('Code', None)
                        instance_status.append(
                            {"id": id, "InstanceStatus": f'{"Running" if code == 16 else "Pending" if code == 0 else "Shutting-down" if code == 32 else "Stopped" if code == 80 else "UNKNOWN"}'})

                    spinner("üñ®Ô∏è", 5)
                    print("**************************************************************")
                    print(response)
                    print_instances_status(instance_status)
                    #print('\n'.join(map(str, instance_status)))
                    print("**************************************************************\n")

                else:
                    print("‚ùå Failed to the check Instance STATUS of: \n" + "'" +
                          instances_ids_list + "'" + "\n ‚ùå")

            else:
                print("***************************************************************************")
                print("‚ÑπÔ∏è Skipping the action ‚Äì " +
                    args['action_type'].upper() + " since zero matching InstanceIds found")
                print("***************************************************************************\n")

        else:
            print("*************************************************************************")
            print('‚ÑπÔ∏è Found ZERO matching instances in the availability zone: "' +
                  args['availability_zone_name'] + '"')
            print("*************************************************************************")

    except botocore.exceptions.ClientError as error:
        print('\n‚ùå Error Code: {}'.format(
            error.response['Error']['Code']))      
        print('\n‚ùå Error Message: {}'.format(
            error.response['Error']['Message']))
        print('‚ùå Request ID: {}'.format(
            error.response['ResponseMetadata']['RequestId']))
        print('‚ùå Http code: {}\n'.format(
            error.response['ResponseMetadata']['HTTPStatusCode']))
        if "request is expired" in error.response['Error']['Message']:
            print("‚ÑπÔ∏è Fix: Rerun 'bash generate_credentials.sh' to regenerate aws credentials\n")
        raise

